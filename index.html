<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>3D Supermarket Simulator</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; /* Disables browser default gestures */
        }

        #game-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* Landscape orientation warning */
        #landscape-warning {
            display: none;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            color: white;
            font-family: sans-serif;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            flex-direction: column;
            text-align: center;
        }

        @media screen and (orientation: portrait) {
            #landscape-warning {
                display: flex;
            }
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none; /* Let clicks pass through to canvas if needed, but we handle touches specifically */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* Crosshair */
        #crosshair {
            position: absolute;
            top: 50%; left: 50%;
            width: 10px; height: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            border: 1px solid black;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
        }

        /* Controls Zones */
        .control-zone {
            position: absolute;
            bottom: 0;
            height: 60%; /* Bottom 60% of screen for controls */
            width: 50%;
            pointer-events: auto;
            /* background: rgba(255, 0, 0, 0.1); Debugging */
        }
        #left-zone { left: 0; }
        #right-zone { right: 0; }

        /* Virtual Joystick */
        #joystick-container {
            position: absolute;
            bottom: 50px; left: 50px;
            width: 100px; height: 100px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.5);
            display: none; /* Hidden until touched */
            pointer-events: none;
        }
        #joystick-knob {
            position: absolute;
            top: 50%; left: 50%;
            width: 40px; height: 40px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        /* Top Bar */
        #top-bar {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 40px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            font-family: sans-serif;
            pointer-events: auto;
        }

        #fullscreen-btn {
            font-size: 12px;
            padding: 5px 10px;
            margin-right: auto;
            margin-left: 10px;
        }

        /* Buttons */
        .game-btn {
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #333;
            border-radius: 8px;
            padding: 10px 20px;
            font-weight: bold;
            font-family: sans-serif;
            color: #333;
            pointer-events: auto;
            touch-action: manipulation;
        }
        .game-btn:active {
            background: #ccc;
        }

        #order-btn {
            /* Positioned in top bar or absolute? Prompt says top corner. Let's put in Top Bar right side or absolute. */
            /* Actually, top bar handles money. Let's put order button just below top bar right side or inside it. */
            /* Prompt: "Screen top corner: Order Button". Top Right is good. */
        }

        #action-btn {
            position: absolute;
            bottom: 40px; right: 40px;
            width: 120px;
            height: 60px;
            font-size: 18px;
            display: none; /* Hidden by default */
            z-index: 20;
        }

    </style>
</head>
<body>

<div id="landscape-warning">
    <h1>Please Rotate Your Device</h1>
    <p>This game is best played in Landscape Mode.</p>
    <button id="force-fullscreen" class="game-btn">Go Fullscreen</button>
</div>

<div id="game-container">
    <div id="ui-layer">
        <div id="top-bar">
            <div id="money-display">Money: $100</div>
            <button id="fullscreen-btn" class="game-btn">Full</button>
            <button id="order-btn" class="game-btn">Order ($20)</button>
        </div>

        <div id="crosshair"></div>

        <div id="left-zone" class="control-zone"></div>
        <div id="right-zone" class="control-zone"></div>

        <div id="joystick-container">
            <div id="joystick-knob"></div>
        </div>

        <button id="action-btn" class="game-btn">Action</button>

        <!-- Price Setting Modal -->
        <div id="price-modal" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); background:white; padding:20px; border-radius:10px; z-index:100; pointer-events:auto; text-align:center;">
            <h3>Set Price</h3>
            <input type="number" id="price-input" style="font-size:18px; width:80px; margin-bottom:10px;"><br>
            <button id="price-save-btn" class="game-btn">Save</button>
            <button id="price-close-btn" class="game-btn" style="background:#fcc;">Cancel</button>
        </div>
    </div>
</div>

<!-- Three.js CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    // --- 1. Scene Setup ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB); // Sky blue background
    scene.fog = new THREE.Fog(0x87CEEB, 1, 50);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.rotation.order = 'YXZ'; // Important for FPS camera to avoid gimbal lock
    camera.position.set(0, 1.6, 5);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.getElementById('game-container').appendChild(renderer.domElement);

    // --- Environment: The Shop ---
    const textureLoader = new THREE.TextureLoader();

    // Floor
    const floorGeometry = new THREE.PlaneGeometry(20, 20);
    const floorMaterial = new THREE.MeshStandardMaterial({
        color: 0xcccccc,
        roughness: 0.8
    });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    floor.userData = { type: 'floor' };
    scene.add(floor);

    // Ceiling
    const ceilingGeometry = new THREE.PlaneGeometry(20, 20);
    const ceilingMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        side: THREE.DoubleSide
    });
    const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
    ceiling.rotation.x = Math.PI / 2;
    ceiling.position.y = 4;
    scene.add(ceiling);

    // Collision Objects List
    const colliders = [];

    // Walls function
    function createWall(width, height, depth, x, y, z, color = 0xeeeeee) {
        const geometry = new THREE.BoxGeometry(width, height, depth);
        const material = new THREE.MeshStandardMaterial({ color: color });
        const wall = new THREE.Mesh(geometry, material);
        wall.position.set(x, y, z);
        wall.receiveShadow = true;
        wall.castShadow = true;
        scene.add(wall);
        colliders.push(wall); // Add to colliders
        return wall;
    }

    // Creating walls
    createWall(20, 4, 1, 0, 2, -10); // Back
    // Front Wall with Door Gap (4 units wide)
    createWall(8, 4, 1, -6, 2, 10);  // Front Left
    createWall(8, 4, 1, 6, 2, 10);   // Front Right
    createWall(1, 4, 20, -10, 2, 0); // Left
    createWall(1, 4, 20, 10, 2, 0);  // Right

    // --- Lighting ---
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    function addLight(x, z) {
        const light = new THREE.PointLight(0xffffee, 0.8, 15);
        light.position.set(x, 3.8, z);
        light.castShadow = true;
        scene.add(light);

        const bulb = new THREE.Mesh(
            new THREE.SphereGeometry(0.2, 16, 16),
            new THREE.MeshBasicMaterial({ color: 0xffffee })
        );
        bulb.position.set(x, 3.9, z);
        scene.add(bulb);
    }

    addLight(-5, -5);
    addLight(5, -5);
    addLight(-5, 5);
    addLight(5, 5);


    // --- Data Structures ---
    const ITEM_TYPES = {
        GUM: {
            id: 'gum',
            size: 1, // 1 slot
            storageType: 'normal',
            boxCapacity: 16, // Enough for 1 full tier (16 slots)
            defaultPrice: 5,
            color: 0xffa500 // Orange box
        }
    };

    class ShelfData {
        constructor(id, type = 'normal', levels = 4) {
            this.id = id;
            this.type = type;
            this.levels = levels;
            // Manage items dynamically, but to enforce size/slot we need slots.
            // 4 levels, 1-indexed (1,2,3,4) to match `tier` in userData
            this.tiers = {};
            for (let i = 1; i <= levels; i++) {
                this.tiers[i] = {
                    slots: new Array(16).fill(null), // 16 slots per tier
                    setPrice: 0,
                    itemType: null, // What item is on this tier
                    count: 0 // How many items total
                };
            }
        }
    }

    let shelfIdCounter = 0;

    // --- Furniture ---
    const shelves = [];

    function createShelf(x, z, rotationY = 0) {
        const group = new THREE.Group();
        const material = new THREE.MeshStandardMaterial({ color: 0x8B4513 });

        const sData = new ShelfData(shelfIdCounter++);

        // Create 4 tiers
        for (let i = 1; i <= 4; i++) {
            const shelfGeo = new THREE.BoxGeometry(4, 0.05, 1);
            const shelf = new THREE.Mesh(shelfGeo, material);
            // Height 2 total. Tiers at 0.5, 1.0, 1.5, 2.0
            shelf.position.y = i * 0.5;
            shelf.castShadow = true;
            shelf.receiveShadow = true;
            shelf.userData = { type: 'shelf', tier: i, shelfData: sData };
            group.add(shelf);
        }

        // Vertical supports (sides)
        const supportGeo = new THREE.BoxGeometry(0.1, 2, 1);
        const leftSupport = new THREE.Mesh(supportGeo, material);
        leftSupport.position.set(-1.95, 1, 0);
        group.add(leftSupport);

        const rightSupport = new THREE.Mesh(supportGeo, material);
        rightSupport.position.set(1.95, 1, 0);
        group.add(rightSupport);

        // For collision (Player can't walk through)
        const collisionBox = new THREE.Mesh(
            new THREE.BoxGeometry(4, 2, 1),
            new THREE.MeshBasicMaterial({ visible: false })
        );
        collisionBox.position.set(x, 1, z);
        collisionBox.rotation.y = rotationY;
        scene.add(collisionBox);
        colliders.push(collisionBox);

        group.position.set(x, 0, z);
        group.rotation.y = rotationY;
        group.userData = { type: 'shelfGroup', shelfData: sData };

        scene.add(group);
        shelves.push(group);
        return group;
    }

    createShelf(-5, -2);
    createShelf(5, -2);
    createShelf(0, -6, Math.PI / 2);

    // Checkout Counter
    const counterGroup = new THREE.Group();
    const counterGeo = new THREE.BoxGeometry(3, 1.2, 1.5);
    const counterMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
    const counter = new THREE.Mesh(counterGeo, counterMat);
    counter.position.y = 0.6;
    counter.castShadow = true;
    counter.receiveShadow = true;
    counter.userData = { type: 'shelf' }; // Allow placing items on counter
    counterGroup.add(counter);
    counterGroup.position.set(4, 0, 6);
    counterGroup.rotation.y = -Math.PI / 4;
    scene.add(counterGroup);

    // Collision for counter
    const counterCollision = new THREE.Mesh(new THREE.BoxGeometry(3, 1.2, 1.5), new THREE.MeshBasicMaterial({visible:false}));
    counterCollision.position.set(4, 0.6, 6);
    counterCollision.rotation.y = -Math.PI / 4;
    scene.add(counterCollision);
    colliders.push(counterCollision);

    // Spawn Pad
    const padGeo = new THREE.PlaneGeometry(2, 2);
    const padMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 });
    const spawnPad = new THREE.Mesh(padGeo, padMat);
    spawnPad.rotation.x = -Math.PI / 2;
    spawnPad.position.set(-8, 0.02, 8);
    spawnPad.userData = { type: 'spawnPad' };
    scene.add(spawnPad);

    // Cashier NPC
    const cashierGroup = new THREE.Group();
    // Body
    const cBodyGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.6, 12);
    const cBodyMat = new THREE.MeshStandardMaterial({ color: 0x0000AA }); // Blue uniform
    const cBody = new THREE.Mesh(cBodyGeo, cBodyMat);
    cBody.position.y = 0.8;
    cBody.castShadow = true;
    cBody.receiveShadow = true;
    cashierGroup.add(cBody);

    // Head
    const cHeadGeo = new THREE.SphereGeometry(0.25, 12, 12);
    const cHeadMat = new THREE.MeshStandardMaterial({ color: 0xffccaa });
    const cHead = new THREE.Mesh(cHeadGeo, cHeadMat);
    cHead.position.y = 1.75;
    cashierGroup.add(cHead);

    // Position behind counter
    cashierGroup.position.set(5.5, 0, 4.5);
    cashierGroup.lookAt(2.5, 0, 7.5); // Face the customer standing point
    scene.add(cashierGroup);


    // --- 3. Interaction & Economy ---

    let money = 100;
    let heldItem = null;
    const products = []; // List of product meshes in scene
    const customers = [];
    const customerSpawnPoint = new THREE.Vector3(0, 0, 15);
    const checkoutPosition = new THREE.Vector3(2.5, 0, 7.5); // In front of counter

    const moneyDisplay = document.getElementById('money-display');
    const orderBtn = document.getElementById('order-btn');
    const actionBtn = document.getElementById('action-btn');
    const fullscreenBtn = document.getElementById('fullscreen-btn');

    const toggleFullscreen = () => {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().then(() => {
                if (screen.orientation && screen.orientation.lock) {
                    screen.orientation.lock('landscape').catch(console.warn);
                }
            }).catch(console.warn);
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        }
    };

    fullscreenBtn.addEventListener('click', toggleFullscreen);
    document.getElementById('force-fullscreen').addEventListener('click', toggleFullscreen);

    function updateMoney(amount) {
        money += amount;
        moneyDisplay.innerText = `Money: $${money}`;
    }

    // Raycaster for interaction
    const raycaster = new THREE.Raycaster();
    const center = new THREE.Vector2(0, 0);
    let interactTarget = null; // Object currently looking at

    // Order Logic
    orderBtn.addEventListener('click', () => {
        if (money >= 20) {
            updateMoney(-20);
            spawnProduct();
        } else {
            alert("Not enough money!");
        }
    });

    function spawnProduct() {
        const geometry = new THREE.BoxGeometry(0.8, 0.6, 0.8); // Make the box larger
        const material = new THREE.MeshStandardMaterial({ color: ITEM_TYPES.GUM.color });
        const box = new THREE.Mesh(geometry, material);

        // Random position on spawn pad (-8, 8) +/- 0.5
        const offsetX = (Math.random() - 0.5) * 1.5;
        const offsetZ = (Math.random() - 0.5) * 1.5;

        box.position.set(-8 + offsetX, 0.5, 8 + offsetZ);
        box.castShadow = true;
        box.receiveShadow = true;

        box.userData = {
            type: 'product', // We keep 'product' for the interaction raycast
            isBox: true,
            itemType: ITEM_TYPES.GUM,
            capacity: ITEM_TYPES.GUM.boxCapacity,
            isResting: false,
            velocity: new THREE.Vector3(0, 0, 0)
        };

        scene.add(box);
        products.push(box);
    }

    function getValidPlacement(target) {
        if (!heldItem) return null;
        if (!target) return null;

        const type = target.userData.type;

        // Raycast again to get precise point
        raycaster.setFromCamera(center, camera);
        const intersects = raycaster.intersectObject(target);
        if (intersects.length === 0) return null;
        const point = intersects[0].point;

        if (type === 'shelf') {
            const shelfGroup = target.parent;
            if (!shelfGroup || shelfGroup.userData.type !== 'shelfGroup') return null;

            const shelfData = shelfGroup.userData.shelfData;
            const tierNum = target.userData.tier;
            const tierData = shelfData.tiers[tierNum];

            // If we are holding a box, check if tier allows this item type
            if (heldItem.userData.isBox) {
                const itemType = heldItem.userData.itemType;
                if (tierData.itemType !== null && tierData.itemType !== itemType) {
                    return null; // Mixed items not allowed
                }
            }

            // Convert to local space
            const localPoint = shelfGroup.worldToLocal(point.clone());

            // Snap Logic (Grid)
            const snapX = Math.round(localPoint.x * 2) / 2;
            const snapZ = Math.round(localPoint.z * 4) / 4;

            // Clamp to stay on shelf
            const clampedX = Math.max(-1.8, Math.min(1.8, snapX));
            const clampedZ = Math.max(-0.4, Math.min(0.4, snapZ));

            // Use the tier's Y position
            const tierY = target.position.y;
            localPoint.set(clampedX, tierY + 0.15, clampedZ);

            // Convert back to world
            const worldPos = localPoint.applyMatrix4(shelfGroup.matrixWorld);

            // Calculate Grid Index based on local snapped positions
            // x: -1.5, -0.5, 0.5, 1.5 -> maps to col 0..3 (ish)
            // z: -0.25, 0.25 -> maps to row 0..1 (ish)
            // Let's use simpler overlap check, but update tierData
            // Find if there's an exact overlap using distance
            for (const p of products) {
                if (p === heldItem) continue;
                if (p.position.distanceTo(worldPos) < 0.2) {
                    return null; // Occupied
                }
            }
            return { pos: worldPos, rot: shelfGroup.rotation, tierData: tierData, tierNum: tierNum, shelfData: shelfData };
        }
        else if (type === 'floor') {
            if (intersects[0].distance > 3) return null;
            const worldPos = point.clone();
            worldPos.y = 0.25;

            // Check overlap
             for (const p of products) {
                if (p === heldItem) continue;
                if (p.position.distanceTo(worldPos) < 0.4) {
                    return null; // Occupied
                }
            }
            return { pos: worldPos, rot: new THREE.Euler(0, 0, 0) };
        }

        return null;
    }

    let currentPricingTier = null;
    let currentPricingShelfData = null;

    document.getElementById('price-save-btn').addEventListener('click', () => {
        if (currentPricingTier && currentPricingShelfData) {
            const newPrice = parseFloat(document.getElementById('price-input').value);
            if (!isNaN(newPrice) && newPrice > 0) {
                currentPricingShelfData.tiers[currentPricingTier].setPrice = newPrice;
            }
        }
        document.getElementById('price-modal').style.display = 'none';
        currentPricingTier = null;
        currentPricingShelfData = null;
    });

    document.getElementById('price-close-btn').addEventListener('click', () => {
        document.getElementById('price-modal').style.display = 'none';
        currentPricingTier = null;
        currentPricingShelfData = null;
    });

    // Action Button Logic
    actionBtn.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent touch from firing joystick/look
        if (!interactTarget) return;

        const type = interactTarget.userData.type;

        if (type === 'customer' && interactTarget.userData.state === 'WAITING') {
            // Checkout Logic
            if (interactTarget.userData.customer.hasItem) {
                updateMoney(30);
                interactTarget.userData.state = 'LEAVING';
                // Feedback
                const feedback = document.createElement('div');
                feedback.innerText = "+$30";
                feedback.style.position = 'absolute';
                feedback.style.top = '50%';
                feedback.style.left = '50%';
                feedback.style.color = 'green';
                feedback.style.fontSize = '24px';
                feedback.style.fontWeight = 'bold';
                feedback.style.animation = 'fadeOut 1s forwards';
                document.body.appendChild(feedback);
                setTimeout(() => feedback.remove(), 1000);

                interactTarget = null;
                updateActionUI();
            }
        }
        else if (type === 'product' && !heldItem) {
            // Pick Up
            heldItem = interactTarget;
            heldItem.userData.isResting = false; // Physics activation

            // Update ShelfData if picking up from a shelf
            const sData = heldItem.userData.shelfData;
            const tierNum = heldItem.userData.tierNum;
            if (sData && tierNum) {
                const tierData = sData.tiers[tierNum];
                tierData.count -= 1;
                if (tierData.count <= 0) {
                    tierData.itemType = null;
                    tierData.setPrice = 0;
                }
                // Remove from slots
                for(let i=0; i<tierData.slots.length; i++) {
                    if(tierData.slots[i] === heldItem) {
                        tierData.slots[i] = null;
                        break;
                    }
                }

                // Clear the shelf data from the item since it's now in hand
                heldItem.userData.shelfData = null;
                heldItem.userData.tierNum = null;
            }

            // Remove from products list so customers don't try to buy it from hand
            // (Actually we keep it in list for physics loop, but handle 'held' state there)
            // But existing code removed it. Let's keep it consistent: remove from scene parent, add to camera.

            // Note: If we remove from products list, physics loop won't update it.
            // But if it's child of camera, we don't need physics loop.
            // When dropped, we add back to products list?
            // The prompt implies gravity should apply. If held, no gravity.

            // Let's ensure it IS in products list when dropped.
            // Current code: `products.push(heldItem)` on drop.
            // Current code: `products.splice(index, 1)` on pickup.
            // This is fine.

            const index = products.indexOf(heldItem);
            if (index > -1) products.splice(index, 1);

            scene.remove(heldItem);
            if (heldItem.parent) heldItem.parent.remove(heldItem);

            camera.add(heldItem);
            heldItem.position.set(0.3, -0.3, -0.5);
            heldItem.rotation.set(0, 0, 0);
        }
        else if (type === 'shelf' && !heldItem) {
            // Open Price Setting UI if looking at a shelf with items
            const shelfGroup = interactTarget.parent;
            if (shelfGroup && shelfGroup.userData.type === 'shelfGroup') {
                const sData = shelfGroup.userData.shelfData;
                const tierNum = interactTarget.userData.tier;
                if (sData && tierNum) {
                    const tierData = sData.tiers[tierNum];
                    if (tierData.itemType !== null) {
                        currentPricingTier = tierNum;
                        currentPricingShelfData = sData;
                        const modal = document.getElementById('price-modal');
                        const input = document.getElementById('price-input');
                        input.value = tierData.setPrice > 0 ? tierData.setPrice : tierData.itemType.defaultPrice;
                        modal.style.display = 'block';
                    }
                }
            }
        }
        else if ((type === 'shelf' || type === 'floor') && heldItem) {
            // Place / Drop using getValidPlacement
            const valid = getValidPlacement(interactTarget);
            if (valid) {
                if (heldItem.userData.isBox && type === 'shelf') {
                    // Place 1 item from box
                    if (heldItem.userData.capacity > 0) {
                        heldItem.userData.capacity -= 1;

                        // Instantiate the item mesh
                        const geom = new THREE.BoxGeometry(0.4, 0.3, 0.4);
                        const mat = new THREE.MeshStandardMaterial({ color: heldItem.userData.itemType.color });
                        const itemMesh = new THREE.Mesh(geom, mat);

                        itemMesh.position.copy(valid.pos);
                        itemMesh.rotation.copy(valid.rot);
                        itemMesh.castShadow = true;
                        itemMesh.receiveShadow = true;

                        itemMesh.userData = {
                            type: 'product',
                            isResting: true,
                            itemType: heldItem.userData.itemType,
                            shelfData: valid.shelfData,
                            tierNum: valid.tierNum
                        };

                        // Update ShelfData
                        valid.tierData.itemType = heldItem.userData.itemType;
                        if (valid.tierData.setPrice === 0) valid.tierData.setPrice = heldItem.userData.itemType.defaultPrice;
                        valid.tierData.count += 1;
                        // Add to slots logic if strict slot array is needed
                        for(let i=0; i<valid.tierData.slots.length; i++) {
                            if(valid.tierData.slots[i] === null) {
                                valid.tierData.slots[i] = itemMesh;
                                break;
                            }
                        }

                        scene.add(itemMesh);
                        products.push(itemMesh);

                        // If box empty, remove it
                        if (heldItem.userData.capacity <= 0) {
                            camera.remove(heldItem);
                            // It was already removed from scene/products on pickup
                            heldItem = null;
                        }
                    }
                } else {
                    // Standard place/drop (e.g. dropping box on floor)
                    camera.remove(heldItem);
                    scene.add(heldItem);
                    products.push(heldItem);

                    heldItem.position.copy(valid.pos);
                    heldItem.rotation.copy(valid.rot);

                    if (type === 'shelf') {
                        heldItem.userData.isResting = true;
                    } else {
                        heldItem.userData.isResting = false;
                    }
                    heldItem = null;
                }
            }
        }

        updateActionUI();
    });

    function updateActionUI() {
        // Raycast loop updates this constantly, but we call it here to handle immediate click feedback
        if (interactTarget) {
            const type = interactTarget.userData.type;
            if (type === 'customer' && interactTarget.userData.state === 'WAITING') {
                actionBtn.style.display = 'block';
                actionBtn.innerText = 'Checkout';
            } else if (type === 'product' && !heldItem) {
                actionBtn.style.display = 'block';
                actionBtn.innerText = 'Pick Up';
            } else if ((type === 'shelf' || type === 'floor') && heldItem) {
                if (getValidPlacement(interactTarget)) {
                    actionBtn.style.display = 'block';
                    actionBtn.innerText = 'Place';
                } else {
                    actionBtn.style.display = 'none';
                }
            } else if (type === 'shelf' && !heldItem) {
                const shelfGroup = interactTarget.parent;
                if (shelfGroup && shelfGroup.userData.type === 'shelfGroup') {
                    const sData = shelfGroup.userData.shelfData;
                    const tierNum = interactTarget.userData.tier;
                    if (sData && tierNum && sData.tiers[tierNum].itemType !== null) {
                        actionBtn.style.display = 'block';
                        actionBtn.innerText = 'Set Price';
                    } else {
                        actionBtn.style.display = 'none';
                    }
                } else {
                    actionBtn.style.display = 'none';
                }
            } else {
                actionBtn.style.display = 'none';
            }
        } else {
            actionBtn.style.display = 'none';
        }
    }

    // --- 4. Customer AI ---

    class Customer {
        constructor() {
            this.mesh = new THREE.Group();

            // Body
            const bodyGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.6, 12);
            const bodyMat = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.8;
            body.castShadow = true;
            body.receiveShadow = true;
            this.mesh.add(body);

            // Head
            const headGeo = new THREE.SphereGeometry(0.25, 12, 12);
            const headMat = new THREE.MeshStandardMaterial({ color: 0xffccaa }); // Skin tone
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 1.75;
            this.mesh.add(head);

            this.mesh.position.copy(customerSpawnPoint);
            this.mesh.userData = { type: 'customer', state: 'SPAWNING', customer: this };

            scene.add(this.mesh);

            this.speed = 2.5; // Meters per second
            this.target = null;
            this.waitTime = 0;
            this.hasItem = false;
            this.desiredItem = ITEM_TYPES.GUM; // Assume customer wants gum for now
            this.heldItemPrice = 0;

            this.state = 'MOVING_TO_SHELF';
            this.findShelf();
        }

        findShelf() {
            // Iterate through shelves and find one with the desired item
            let targetShelf = null;

            // Gather all shelves that have the item
            const validShelves = [];
            for (const shelf of shelves) {
                const sData = shelf.userData.shelfData;
                for (let i = 1; i <= sData.levels; i++) {
                    const tier = sData.tiers[i];
                    if (tier.itemType === this.desiredItem && tier.count > 0) {
                        validShelves.push(shelf);
                        break; // Only need to know shelf has it
                    }
                }
            }

            if (validShelves.length > 0) {
                targetShelf = validShelves[Math.floor(Math.random() * validShelves.length)];
            } else {
                // If no shelf has it, just pick a random shelf to look at
                targetShelf = shelves[Math.floor(Math.random() * shelves.length)];
            }

            // Target is slightly in front of the shelf
            // Shelf is at (x, 0, z). We need to know where "front" is.
            // Simple logic: If shelf x < 0, stand at x + 1. If shelf x > 0, stand at x - 1.
            const sPos = targetShelf.position;
            // Hacky target position based on shelf positions
            if (sPos.z < -4) { // Back shelf
                this.target = new THREE.Vector3(sPos.x, 0, sPos.z + 1.5);
            } else {
                 this.target = new THREE.Vector3(sPos.x > 0 ? sPos.x - 1.5 : sPos.x + 1.5, 0, sPos.z);
            }
        }

        update(delta) {
            const pos = this.mesh.position;

            if (this.state === 'MOVING_TO_SHELF') {
                if (this.moveTo(this.target, delta)) {
                    this.state = 'TAKING_ITEM';
                    this.waitTime = 2.0;
                }
            }
            else if (this.state === 'TAKING_ITEM') {
                this.waitTime -= delta;
                if (this.waitTime <= 0) {
                    // Try to find a product nearby to "buy" (remove)
                    let foundProduct = null;
                    let minDist = 2.0;

                    // Only look for items that match desiredItem and are resting on a shelf
                    for (let i = products.length - 1; i >= 0; i--) {
                        const prod = products[i];
                        if (!prod.userData.isBox && prod.userData.itemType === this.desiredItem && prod.userData.shelfData) {
                            const d = prod.position.distanceTo(pos);
                            if (d < minDist) {
                                minDist = d;
                                foundProduct = prod;
                            }
                        }
                    }

                    if (foundProduct) {
                        // Safe removal
                        if (foundProduct.parent) foundProduct.parent.remove(foundProduct);

                        const idx = products.indexOf(foundProduct);
                        if (idx > -1) products.splice(idx, 1);

                        // Update ShelfData
                        const sData = foundProduct.userData.shelfData;
                        const tierNum = foundProduct.userData.tierNum;
                        if (sData && tierNum) {
                            const tierData = sData.tiers[tierNum];
                            tierData.count -= 1;
                            if (tierData.count <= 0) {
                                tierData.itemType = null;
                                tierData.setPrice = 0;
                            }
                            this.heldItemPrice = tierData.setPrice > 0 ? tierData.setPrice : this.desiredItem.defaultPrice;

                            // Remove from slots array
                            for(let i=0; i<tierData.slots.length; i++) {
                                if(tierData.slots[i] === foundProduct) {
                                    tierData.slots[i] = null;
                                    break;
                                }
                            }
                        }

                        // Visual: hold item
                        const item = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), foundProduct.material);
                        item.position.set(0.3, 1, 0.3);
                        this.mesh.add(item);
                        this.hasItem = true;
                    }

                    this.state = 'MOVING_TO_CHECKOUT';
                    this.target = checkoutPosition.clone();
                }
            }
            else if (this.state === 'MOVING_TO_CHECKOUT') {
                if (this.moveTo(this.target, delta)) {
                    this.state = 'WAITING';
                    this.mesh.userData.state = 'WAITING'; // Sync for raycast
                    // Turn to face counter
                    this.mesh.lookAt(4, 0.8, 6);
                }
            }
            else if (this.state === 'WAITING') {
                // Wait for player interaction (handled in main loop via raycast)
                // this.mesh.userData.state is updated by player click
                if (this.mesh.userData.state === 'LEAVING') {
                    this.state = 'LEAVING';
                    // Move to door first (gap at z=10, x=0)
                    this.target = new THREE.Vector3(0, 0, 10);
                }
            }
            else if (this.state === 'LEAVING') {
                if (this.moveTo(this.target, delta)) {
                    // If we reached the door, now move to spawn point to despawn
                    if (this.target.z === 10) {
                        this.target = customerSpawnPoint.clone();
                    } else {
                        this.despawn();
                        return false; // Removed
                    }
                }
            }
            return true; // Still active
        }

        moveTo(target, delta) {
            const direction = new THREE.Vector3().subVectors(target, this.mesh.position);
            direction.y = 0;
            const dist = direction.length();

            if (dist < 0.1) return true; // Reached

            direction.normalize();
            this.mesh.position.addScaledVector(direction, this.speed * delta);

            // Look at target
            const lookTarget = target.clone();
            lookTarget.y = this.mesh.position.y;
            this.mesh.lookAt(lookTarget);

            return false;
        }

        despawn() {
            scene.remove(this.mesh);
        }
    }

    // Spawner
    let spawnTimer = 0;
    const spawnInterval = 10; // Seconds

    // --- 2. Mobile Controls ---

    // State
    const player = {
        speed: 0.05,
        velocity: new THREE.Vector3(),
        direction: new THREE.Vector3(),
        rotation: new THREE.Euler(0, 0, 0, 'YXZ')
    };

    // Joystick Variables
    let moveForward = 0; // -1 to 1
    let moveRight = 0;   // -1 to 1
    let joystickActive = false;
    let joystickTouchId = null;
    let joystickCenter = { x: 0, y: 0 };
    const maxJoystickRadius = 40;

    // Look Variables
    let lookTouchId = null;
    let lastLookX = 0;
    let lastLookY = 0;
    const lookSensitivity = 0.015;

    // UI Elements
    const joystickContainer = document.getElementById('joystick-container');
    const joystickKnob = document.getElementById('joystick-knob');
    const leftZone = document.getElementById('left-zone');
    const rightZone = document.getElementById('right-zone');

    // --- Left Zone: Movement (Joystick) ---
    leftZone.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.changedTouches[0];
        joystickTouchId = touch.identifier;
        joystickActive = true;

        // Set joystick position to touch start
        joystickCenter.x = touch.clientX;
        joystickCenter.y = touch.clientY;

        joystickContainer.style.display = 'block';
        joystickContainer.style.left = (touch.clientX - 50) + 'px';
        joystickContainer.style.top = (touch.clientY - 50) + 'px';
        joystickKnob.style.transform = `translate(-50%, -50%)`;

        moveForward = 0;
        moveRight = 0;
    }, { passive: false });

    leftZone.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (!joystickActive) return;

        let touch = null;
        for (let i = 0; i < e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier === joystickTouchId) {
                touch = e.changedTouches[i];
                break;
            }
        }
        if (!touch) return;

        const deltaX = touch.clientX - joystickCenter.x;
        const deltaY = touch.clientY - joystickCenter.y;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

        const clampedDistance = Math.min(distance, maxJoystickRadius);
        const angle = Math.atan2(deltaY, deltaX);

        const knobX = Math.cos(angle) * clampedDistance;
        const knobY = Math.sin(angle) * clampedDistance;

        joystickKnob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;

        // Normalize inputs (-1 to 1)
        moveRight = knobX / maxJoystickRadius;
        moveForward = -(knobY / maxJoystickRadius); // Inverted Y for forward
    }, { passive: false });

    const endJoystick = (e) => {
        e.preventDefault();
        for (let i = 0; i < e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier === joystickTouchId) {
                joystickActive = false;
                joystickTouchId = null;
                joystickContainer.style.display = 'none';
                moveForward = 0;
                moveRight = 0;
                break;
            }
        }
    };
    leftZone.addEventListener('touchend', endJoystick);
    leftZone.addEventListener('touchcancel', endJoystick);

    // --- Right Zone: Look (Camera Rotation) ---
    rightZone.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.changedTouches[0];
        lookTouchId = touch.identifier;
        lastLookX = touch.clientX;
        lastLookY = touch.clientY;
    }, { passive: false });

    rightZone.addEventListener('touchmove', (e) => {
        e.preventDefault();
        let touch = null;
        for (let i = 0; i < e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier === lookTouchId) {
                touch = e.changedTouches[i];
                break;
            }
        }
        if (!touch) return;

        const deltaX = touch.clientX - lastLookX;
        const deltaY = touch.clientY - lastLookY;

        camera.rotation.y -= deltaX * lookSensitivity;
        camera.rotation.x -= deltaY * lookSensitivity;

        // Clamp Pitch (Up/Down) to avoid flipping
        camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));

        lastLookX = touch.clientX;
        lastLookY = touch.clientY;
    }, { passive: false });

    const endLook = (e) => {
        e.preventDefault();
        for (let i = 0; i < e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier === lookTouchId) {
                lookTouchId = null;
                break;
            }
        }
    };
    rightZone.addEventListener('touchend', endLook);
    rightZone.addEventListener('touchcancel', endLook);


    // --- Collision Logic (Simple AABB) ---
    function checkCollision(position) {
        const playerRadius = 0.5; // Approximate player width
        const playerBox = new THREE.Box3();
        playerBox.min.set(position.x - playerRadius, position.y - 1, position.z - playerRadius);
        playerBox.max.set(position.x + playerRadius, position.y + 1, position.z + playerRadius);

        for (const collider of colliders) {
            const colliderBox = new THREE.Box3().setFromObject(collider);
            if (playerBox.intersectsBox(colliderBox)) {
                return true;
            }
        }
        return false;
    }

    // --- Game Loop ---
    const clock = new THREE.Clock();
    console.log("Game initialized, starting loop");

    // Cashier Logic
    let cashierTimer = 0;
    const cashierProcessTime = 2.0; // Seconds to process

    function updateCashier(delta) {
        // Find customer at checkout
        let customerAtCheckout = null;
        for (const c of customers) {
            if (c.state === 'WAITING') {
                customerAtCheckout = c;
                break;
            }
        }

        if (customerAtCheckout) {
            cashierTimer += delta;
            if (cashierTimer > cashierProcessTime) {
                // Checkout!
                if (customerAtCheckout.hasItem) {
                    const earnings = customerAtCheckout.heldItemPrice || 30; // fallback just in case
                    updateMoney(earnings);
                    // Feedback
                    const feedback = document.createElement('div');
                    feedback.innerText = "+$" + earnings;
                    feedback.style.position = 'absolute';
                    feedback.style.top = '20%';
                    feedback.style.left = '50%';
                    feedback.style.transform = 'translateX(-50%)';
                    feedback.style.color = 'green';
                    feedback.style.fontSize = '24px';
                    feedback.style.fontWeight = 'bold';
                    feedback.style.animation = 'fadeOut 1s forwards';
                    feedback.style.pointerEvents = 'none';
                    document.body.appendChild(feedback);
                    setTimeout(() => feedback.remove(), 1000);
                }

                customerAtCheckout.state = 'LEAVING';
                customerAtCheckout.mesh.userData.state = 'LEAVING'; // Sync for other systems

                cashierTimer = 0;
            }
        } else {
            cashierTimer = 0;
        }
    }

    function animate() {
        requestAnimationFrame(animate);

        const delta = clock.getDelta(); // Time between frames

        // Physics Loop for Products
        for (const p of products) {
            // Held items are removed from this list, so this only affects free items
            if (!p.userData.isResting) {
                // Apply Gravity
                if (!p.userData.velocity) p.userData.velocity = new THREE.Vector3(0,0,0);

                p.userData.velocity.y -= 9.8 * delta;
                p.position.addScaledVector(p.userData.velocity, delta);

                // Floor Collision
                if (p.position.y < 0.25) {
                    p.position.y = 0.25;
                    p.userData.velocity.y = 0;
                    p.userData.isResting = true;
                }
            }
        }

        updateCashier(delta);

        // Movement Logic
        if (moveForward !== 0 || moveRight !== 0) {
            // Calculate forward and right vectors based on camera rotation (Y-axis only)
            const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), camera.rotation.y);
            const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), camera.rotation.y);

            // Create movement vector
            const moveVec = new THREE.Vector3();
            moveVec.addScaledVector(forward, moveForward); // Forward is -Z relative to camera
            moveVec.addScaledVector(right, moveRight);

            // Normalize direction but keep magnitude for analog control
            const inputLen = Math.min(1, Math.sqrt(moveForward*moveForward + moveRight*moveRight));
            if (inputLen > 0) {
                moveVec.normalize().multiplyScalar(player.speed * inputLen);
            }

            // Proposed new position
            const newPos = camera.position.clone().add(moveVec);

            // Simple Collision Check (X axis)
            const testPosX = camera.position.clone();
            testPosX.x = newPos.x;
            if (!checkCollision(testPosX)) {
                camera.position.x = newPos.x;
            }

            // Simple Collision Check (Z axis)
            const testPosZ = camera.position.clone();
            testPosZ.z = newPos.z;
            if (!checkCollision(testPosZ)) {
                camera.position.z = newPos.z;
            }
        }

        // --- Interaction Raycast Loop ---
        raycaster.setFromCamera(center, camera);

        // We only interact with visible things.
        // If holding item, we ignore the held item itself (which is child of camera).
        // Filter out held item from raycast candidates if needed, but since it's child of camera and we raycast against scene.children (except if recursively), it might be tricky.
        // Actually scene.children contains camera? No.
        // But if heldItem is child of camera, it is NOT in scene.children direct list.
        // However, we should be careful.

        const intersects = raycaster.intersectObjects(scene.children, true);

        let found = null;
        for (let i = 0; i < intersects.length; i++) {
            const obj = intersects[i].object;
            // Skip invisible collision boxes
            if (obj.visible === false) continue;
            // Skip Held Item
            if (heldItem && (obj === heldItem || obj.parent === heldItem)) continue;

            if (obj.userData.type) {
                found = obj;
                break;
            }
        }

        interactTarget = found;

        // Update Customer Logic
        spawnTimer += delta;
        if (spawnTimer > spawnInterval) {
            if (customers.length < 5) {
                const customer = new Customer();
                customers.push(customer);
                spawnTimer = 0;
            }
        }

        for (let i = customers.length - 1; i >= 0; i--) {
            const active = customers[i].update(delta);
            if (!active) {
                customers.splice(i, 1);
            }
        }

        // Update Action Button UI (Use the helper we created)
        updateActionUI();

        renderer.render(scene, camera);
    }
    animate();

    // --- Resize Handler ---
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>
