<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>3D 모바일 슈퍼마켓 v2</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #2c3e50; 
            touch-action: none; /* 브라우저 스크롤 방지 */
            -webkit-user-select: none;
            user-select: none;
        }
        #ui-layer { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            color: white; 
            font-family: 'Segoe UI', sans-serif; 
            font-size: 18px; 
            font-weight: bold; 
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            pointer-events: none; 
            z-index: 10;
        }
        /* 주문 버튼 UI */
        #order-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            background-color: #e67e22;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            pointer-events: auto; /* 터치 가능하게 */
            z-index: 10;
        }
        #order-btn:active {
            background-color: #d35400;
            transform: translateY(2px);
        }
        /* 동적 조이스틱 영역 (평소엔 숨김) */
        #joystick-base { 
            position: absolute; 
            width: 120px; 
            height: 120px; 
            background: rgba(255, 255, 255, 0.2); 
            border-radius: 50%; 
            transform: translate(-50%, -50%);
            display: none; 
            pointer-events: none; 
            border: 2px solid rgba(255,255,255,0.4);
            z-index: 5;
        }
        #joystick-knob { 
            width: 50px; 
            height: 50px; 
            background: rgba(255, 255, 255, 0.8); 
            border-radius: 50%; 
            position: absolute; 
            top: 35px; left: 35px; /* base의 중앙 */
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            pointer-events: none;
        }
        #notification {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(46, 204, 113, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-family: sans-serif;
            font-weight: bold;
            display: none;
            z-index: 10;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="ui-layer">
        소지금: <span id="money">500</span>원<br>
        재고 박스: <span id="inventory">0</span>개<br>
        <span style="font-size: 14px; color: #f1c40f;">화면 아무 곳이나 터치해서 이동!</span>
    </div>
    
    <button id="order-btn">물건 주문 (-100원)</button>
    <div id="notification">배송 완료! 입구에서 상자를 픽업해!</div>

    <div id="joystick-base">
        <div id="joystick-knob"></div>
    </div>

    <script>
        // === 1. Three.js 기본 설정 ===
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x95a5a6);

        const aspect = window.innerWidth / window.innerHeight;
        const d = 10; // 맵이 작아졌으므로 카메라 시야도 좁힘
        const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
        camera.position.set(20, 20, 20);
        camera.lookAt(scene.position);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(10, 20, 10);
        light.castShadow = true;
        scene.add(light);
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));

        // === 2. 맵 구현 (가게 크기 줄임) ===
        // 가게 바닥 (16x16)
        const storeSize = 16;
        const floorGeo = new THREE.PlaneGeometry(storeSize, storeSize);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0xbdc3c7 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        const obstacles = [];

        // 벽, 오브젝트 생성 헬퍼 함수
        function createBox(w, h, depth, x, z, color, isWall = false) {
            const geo = new THREE.BoxGeometry(w, h, depth);
            const mat = new THREE.MeshStandardMaterial({ color: color });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, h / 2, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            obstacles.push({ box: new THREE.Box3().setFromObject(mesh), mesh: mesh });
            return mesh;
        }

        // 벽 세팅 (입구 뚫어놓기)
        const wallH = 3;
        const wallColor = 0x7f8c8d;
        createBox(storeSize, wallH, 1, 0, -8.5, wallColor, true); // 뒷벽
        createBox(1, wallH, storeSize, -8.5, 0, wallColor, true); // 왼벽
        createBox(1, wallH, storeSize, 8.5, 0, wallColor, true);  // 오른벽
        createBox(6, wallH, 1, -5, 8.5, wallColor, true); // 앞벽 (왼쪽)
        createBox(6, wallH, 1, 5, 8.5, wallColor, true);  // 앞벽 (오른쪽) - 가운데 4칸은 입구!

        // 진열대 및 카운터 세팅
        createBox(3, 2, 1, -4, -3, 0xd35400); // 진열대 1
        createBox(3, 2, 1, 4, -3, 0xd35400);  // 진열대 2
        createBox(2, 1.5, 4, 4, 3, 0x2c3e50); // 카운터 (길게)

        // 배송 도착 지점 표시 (입구 밖)
        const deliveryZoneGeo = new THREE.PlaneGeometry(3, 3);
        const deliveryZoneMat = new THREE.MeshBasicMaterial({ color: 0xf39c12, transparent: true, opacity: 0.5 });
        const deliveryZone = new THREE.Mesh(deliveryZoneGeo, deliveryZoneMat);
        deliveryZone.rotation.x = -Math.PI / 2;
        deliveryZone.position.set(0, 0.01, 11);
        scene.add(deliveryZone);

        // === 3. 사람 형태 캐릭터 만들기 ===
        function createHuman(bodyColor) {
            const group = new THREE.Group();
            
            // 머리 (피부색)
            const headMat = new THREE.MeshStandardMaterial({ color: 0xffccaa });
            const headGeo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 1.6;
            head.castShadow = true;
            
            // 몸통
            const bodyMat = new THREE.MeshStandardMaterial({ color: bodyColor });
            const bodyGeo = new THREE.BoxGeometry(0.8, 1, 0.4);
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.8;
            body.castShadow = true;

            group.add(head);
            group.add(body);
            return group;
        }

        const player = createHuman(0x3498db); // 플레이어는 파란옷
        player.position.set(0, 0, 4);
        scene.add(player);

        // === 4. 게임 시스템 상태 ===
        let money = 500;
        let inventory = 0;
        let deliveryBoxes = []; // 배달된 상자들

        // 주문 시스템 이벤트
        document.getElementById('order-btn').addEventListener('click', () => {
            if (money >= 100) {
                money -= 100;
                document.getElementById('money').innerText = money;
                
                // 3초 후 배송 완료
                setTimeout(() => {
                    spawnDeliveryBox();
                }, 3000);
            }
        });

        function spawnDeliveryBox() {
            // 상자 메쉬 생성
            const box = createBox(1, 1, 1, (Math.random() - 0.5) * 2, 11 + (Math.random() - 0.5) * 2, 0xcd6155);
            deliveryBoxes.push(box);
            
            // 알림 띄우기
            const noti = document.getElementById('notification');
            noti.style.display = 'block';
            setTimeout(() => { noti.style.display = 'none'; }, 2000);
        }

        // === 5. 동적 조이스틱 시스템 (화면 터치 위치 기준 360도) ===
        const joystickBase = document.getElementById('joystick-base');
        const joystickKnob = document.getElementById('joystick-knob');
        let isDragging = false;
        let joystickCenter = { x: 0, y: 0 };
        let moveVector = new THREE.Vector2(0, 0);
        const maxRadius = 40;

        // 캔버스 자체에 터치 이벤트 걸기 (버튼 터치와 겹치지 않게)
        renderer.domElement.addEventListener('touchstart', (e) => {
            isDragging = true;
            const touch = e.touches[0];
            joystickCenter.x = touch.clientX;
            joystickCenter.y = touch.clientY;
            
            joystickBase.style.left = joystickCenter.x + 'px';
            joystickBase.style.top = joystickCenter.y + 'px';
            joystickBase.style.display = 'block';
            
            updateJoystick(touch);
        });

        renderer.domElement.addEventListener('touchmove', (e) => {
            if (!isDragging) return;
            updateJoystick(e.touches[0]);
        }, { passive: false });

        renderer.domElement.addEventListener('touchend', () => {
            isDragging = false;
            joystickBase.style.display = 'none';
            joystickKnob.style.transform = `translate(0px, 0px)`;
            moveVector.set(0, 0);
        });

        function updateJoystick(touch) {
            let dx = touch.clientX - joystickCenter.x;
            let dy = touch.clientY - joystickCenter.y;
            
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > maxRadius) {
                dx = (dx / distance) * maxRadius;
                dy = (dy / distance) * maxRadius;
            }
            
            joystickKnob.style.transform = `translate(${dx}px, ${dy}px)`;
            
            // 속도 조절
            moveVector.x = dx * 0.004;
            moveVector.y = dy * 0.004;
        }

        // === 6. 게임 루프 & 미끄러지는 충돌 처리 (Sliding Collision) ===
        const angleOffset = Math.PI / 4; 
        const playerRadius = 0.4; // 플레이어 충돌 크기 반경

        function animate() {
            requestAnimationFrame(animate);

            if (isDragging) {
                // 입력 벡터를 카메라 시점(45도)에 맞게 회전
                const moveX = moveVector.x * Math.cos(angleOffset) + moveVector.y * Math.sin(angleOffset);
                const moveZ = -moveVector.x * Math.sin(angleOffset) + moveVector.y * Math.cos(angleOffset);

                // --- 미끄러지는 충돌 처리 ---
                // X축 이동 시도
                player.position.x += moveX;
                let playerBox = new THREE.Box3().setFromCenterAndSize(
                    new THREE.Vector3(player.position.x, 1, player.position.z), 
                    new THREE.Vector3(playerRadius * 2, 2, playerRadius * 2)
                );
                
                for (let obs of obstacles) {
                    if (playerBox.intersectsBox(obs.box)) {
                        player.position.x -= moveX; // 충돌하면 X축 이동 취소
                        break;
                    }
                }

                // Z축 이동 시도
                player.position.z += moveZ;
                playerBox.setFromCenterAndSize(
                    new THREE.Vector3(player.position.x, 1, player.position.z), 
                    new THREE.Vector3(playerRadius * 2, 2, playerRadius * 2)
                );

                for (let obs of obstacles) {
                    if (playerBox.intersectsBox(obs.box)) {
                        player.position.z -= moveZ; // 충돌하면 Z축 이동 취소
                        break;
                    }
                }
                
                // 이동하는 방향으로 캐릭터 회전시키기
                if (moveX !== 0 || moveZ !== 0) {
                    player.rotation.y = Math.atan2(moveX, moveZ);
                }
            }

            // 배송 상자 픽업 로직 (거리가 가까워지면 자동 획득)
            for (let i = deliveryBoxes.length - 1; i >= 0; i--) {
                let boxMesh = deliveryBoxes[i];
                // 플레이어와 박스 사이 거리 계산
                if (player.position.distanceTo(boxMesh.position) < 1.5) {
                    scene.remove(boxMesh); // 씬에서 박스 삭제
                    
                    // obstacles 배열에서도 삭제 (충돌 판정 제거)
                    let obsIdx = obstacles.findIndex(o => o.mesh === boxMesh);
                    if(obsIdx > -1) obstacles.splice(obsIdx, 1);

                    deliveryBoxes.splice(i, 1); // 배열에서 삭제
                    
                    inventory += 1; // 인벤토리 증가
                    document.getElementById('inventory').innerText = inventory;
                }
            }

            // 카메라 따라가기
            camera.position.x = player.position.x + 15;
            camera.position.z = player.position.z + 15;
            camera.lookAt(player.position);

            renderer.render(scene, camera);
        }
        
        animate();

        // 화면 리사이즈 대응
        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
