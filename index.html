<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>3D 모바일 슈퍼마켓</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #2c3e50; 
            touch-action: none; /* 브라우저 기본 터치 액션 막기 */
        }
        /* UI 스타일 */
        #ui-layer { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            color: white; 
            font-family: 'Segoe UI', sans-serif; 
            font-size: 20px; 
            font-weight: bold; 
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            pointer-events: none; 
        }
        /* 가상 조이스틱 영역 */
        #joystick-zone { 
            position: absolute; 
            bottom: 8%; 
            left: 50%; 
            transform: translateX(-50%); 
            width: 140px; 
            height: 140px; 
            background: rgba(255, 255, 255, 0.2); 
            border-radius: 50%; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            touch-action: none; 
            border: 2px solid rgba(255,255,255,0.4);
        }
        /* 조이스틱 손잡이 */
        #joystick-knob { 
            width: 60px; 
            height: 60px; 
            background: rgba(255, 255, 255, 0.8); 
            border-radius: 50%; 
            position: absolute; 
            pointer-events: none; 
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="ui-layer">
        소지금: <span id="money">0</span>원<br>
        <span style="font-size: 14px; color: #f1c40f;">하단 원을 터치해 이동해 봐!</span>
    </div>

    <div id="joystick-zone">
        <div id="joystick-knob"></div>
    </div>

    <script>
        // 1. Three.js 기본 설정 (씬, 카메라, 렌더러)
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xecf0f1);

        // 직교 카메라(Orthographic)를 사용해 완벽한 쿼터뷰(아이소메트릭) 느낌 연출
        const aspect = window.innerWidth / window.innerHeight;
        const d = 12; // 카메라 시야 범위
        const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
        
        // 쿼터뷰 각도 설정 (우측 상단에서 대각선 아래로 바라봄)
        camera.position.set(20, 20, 20);
        camera.lookAt(scene.position);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        // 그림자 활성화
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // 2. 조명 설정
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(10, 20, 10);
        light.castShadow = true;
        scene.add(light);
        scene.add(new THREE.AmbientLight(0xffffff, 0.6)); // 전체를 밝혀주는 기본 빛

        // 3. 맵 구현 (바닥)
        const floorGeo = new THREE.PlaneGeometry(50, 50);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0xbdc3c7 });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // 장애물(진열대, 계산대) 배열
        const obstacles = [];

        // 물건 만들기 함수
        function createBox(w, h, depth, x, z, color) {
            const geo = new THREE.BoxGeometry(w, h, depth);
            const mat = new THREE.MeshStandardMaterial({ color: color });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, h / 2, z);
            mesh.castShadow = true;
            scene.add(mesh);
            obstacles.push(mesh);
            return mesh;
        }

        // 진열대 세팅
        createBox(4, 3, 1.5, -4, -2, 0xd35400); // 좌측 진열대 1
        createBox(4, 3, 1.5, -4, 3, 0xd35400);  // 좌측 진열대 2
        createBox(4, 3, 1.5, 4, -2, 0xd35400);  // 우측 진열대
        // 계산대 세팅
        createBox(3, 1.5, 2, 4, 5, 0x2c3e50);

        // 4. 플레이어 캐릭터
        const playerGeo = new THREE.CylinderGeometry(0.5, 0.5, 2, 16);
        const playerMat = new THREE.MeshStandardMaterial({ color: 0x3498db });
        const player = new THREE.Mesh(playerGeo, playerMat);
        player.position.set(0, 1, 6);
        player.castShadow = true;
        scene.add(player);

        // 5. NPC (손님) 캐릭터
        const npcGeo = new THREE.CylinderGeometry(0.5, 0.5, 2, 16);
        const npcMat = new THREE.MeshStandardMaterial({ color: 0xe74c3c });
        const npc = new THREE.Mesh(npcGeo, npcMat);
        npc.position.set(-5, 1, 8);
        npc.castShadow = true;
        scene.add(npc);
        
        let npcTargets = [
            new THREE.Vector3(-2, 1, -2), // 진열대 앞 1
            new THREE.Vector3(2, 1, 5),   // 계산대 앞
            new THREE.Vector3(-5, 1, 8)   // 입구
        ];
        let currentTargetIdx = 0;

        // 6. 가상 조이스틱 로직 (360도 이동)
        const zone = document.getElementById('joystick-zone');
        const knob = document.getElementById('joystick-knob');
        let isDragging = false;
        let moveVector = new THREE.Vector2(0, 0);
        const maxRadius = 50; // 조이스틱 최대 이동 반경

        zone.addEventListener('touchstart', (e) => { isDragging = true; updateJoystick(e.touches[0]); });
        zone.addEventListener('touchmove', (e) => { if(isDragging) updateJoystick(e.touches[0]); }, {passive: false});
        zone.addEventListener('touchend', () => { 
            isDragging = false; 
            knob.style.transform = `translate(0px, 0px)`;
            moveVector.set(0, 0); // 손을 떼면 멈춤
        });

        function updateJoystick(touch) {
            const rect = zone.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            let dx = touch.clientX - centerX;
            let dy = touch.clientY - centerY;
            
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > maxRadius) {
                dx = (dx / distance) * maxRadius;
                dy = (dy / distance) * maxRadius;
            }
            
            knob.style.transform = `translate(${dx}px, ${dy}px)`;
            
            // 이동 속도 조절
            moveVector.x = dx * 0.003;
            moveVector.y = dy * 0.003;
        }

        // 카메라가 45도 틀어져 있으므로, 입력 벡터를 회전시켜서 직관적인 조작을 만듦
        const angleOffset = Math.PI / 4; 

        // 7. 게임 루프 (업데이트 & 렌더링)
        function animate() {
            requestAnimationFrame(animate);

            // 플레이어 이동 로직
            if (isDragging) {
                // 화면의 x, y 드래그를 3D 공간의 x, z로 변환 (카메라 시점에 맞게 45도 회전)
                const rotatedX = moveVector.x * Math.cos(angleOffset) + moveVector.y * Math.sin(angleOffset);
                const rotatedZ = -moveVector.x * Math.sin(angleOffset) + moveVector.y * Math.cos(angleOffset);
                
                const nextX = player.position.x + rotatedX;
                const nextZ = player.position.z + rotatedZ;

                // 충돌 감지 (AABB 방식)
                let collision = false;
                const playerBox = new THREE.Box3().setFromObject(player);
                playerBox.translate(new THREE.Vector3(rotatedX, 0, rotatedZ)); // 다음 이동할 위치 미리 계산

                for (let obs of obstacles) {
                    const obsBox = new THREE.Box3().setFromObject(obs);
                    if (playerBox.intersectsBox(obsBox)) {
                        collision = true;
                        break;
                    }
                }

                if (!collision) {
                    player.position.x = nextX;
                    player.position.z = nextZ;
                }
            }

            // NPC 이동 로직 (간단한 웨이포인트 이동)
            let targetPos = npcTargets[currentTargetIdx];
            if (npc.position.distanceTo(targetPos) > 0.1) {
                // 목표를 향해 조금씩 이동 (Lerp)
                npc.position.lerp(targetPos, 0.02);
            } else {
                // 목표 도달 시 다음 장소로
                currentTargetIdx = (currentTargetIdx + 1) % npcTargets.length;
            }

            // 카메라가 플레이어를 부드럽게 따라가도록 설정
            camera.position.x = player.position.x + 20;
            camera.position.z = player.position.z + 20;
            camera.lookAt(player.position);

            renderer.render(scene, camera);
        }
        
        animate();

        // 8. 모바일 화면 회전이나 크기 변경 시 대응
        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
